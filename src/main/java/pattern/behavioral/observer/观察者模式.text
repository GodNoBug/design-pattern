观察者模式
    又被称为发布-订阅(Publish/Subscribe)模式.它定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个
  主题对象。这个主题对象在状态变化时,会通知所有的观察者对象,使他们能够自动更新自己。
        - 主题: 出版者/被观察者
        - 观察者: 订阅者,主题的所有依赖者

在观察者模式中有如下角色：
    - Subject：抽象主题(抽象被观察者)
          抽象主题角色把所有观察者对象保存在一个集合里,每个主题都可以有任意数量的观察者,抽象主题提供一个接口,
       可以增加和删除观察者对象。
    - ConcreteSubject：具体主题(具体被观察者)
          该角色将有关状态存入具体观察者对象,在具体主题的内部状态发生改变时,给所有注册过的观察者发送通知。
    - Observer：抽象观察者,是观察者的抽象类,它定义了一个更新接口,使得在得到主题更改通知时更新自己。
    - ConcreteObserver：具体观察者,实现抽象观察者定义的更新接口,以便在得到主题更改通知时更新自身的状态。


优缺点
    优点：
        - 降低了目标与观察者之间的耦合关系,两者之间是抽象耦合关系。
        - 被观察者发送通知,所有注册的观察者都会收到信息【可以实现广播机制】
    缺点：
        - 如果观察者非常多的话,那么所有的观察者收到被观察者发送的通知会耗时
        - 如果被观察者有循环依赖的话,那么被观察者发送通知会使观察者循环调用,会导致系统崩溃
使用场景
        - 对象间存在一对多关系,一个对象的状态发生改变会影响其他对象。
        - 当一个抽象模型有两个方面,其中一个方面依赖于另一方面时。

观察者模式提供了一种对象设计,让主题和观察者之间松耦合
    关于观察者的一切,主题只知道观察者实现了某个接口(也就是Observer接口).主题不需要知道观察者的具体类是谁,做了
 些什么或者其他任何细节
    任何时候我们都可以增加新的观察者.因为主题唯一依赖的东西就是一个实现Observer接口的对象列表,所以我们可以随时
 增加观察者.事实上,在运行时我们可以用新的观察者取代现有的观察者,主题不会受到任何影响.同样的,也可以在任何时候删除
 某些观察者
    若观察者为了取得信息,就必须先想向主题注册
    每个观察者都会有差异,这就是为什么需要一个共同的就抽象观察者接口,尽管观察者有差异,但是有共同的接口,主题就能够
    知道如何把变化传递给他们

JDK
        在Java中,通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式,只要实现它们的子类
    就可以编写观察者模式实例。

    1,Observable类
        Observable 类是抽象目标类(被观察者),它有一个 Vector 集合成员变量,用于保存所有要通知的观察者对象,下面来介绍
        它最重要的 3 个方法。
            void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。
            void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的
                 update方法,通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。
            void setChange() 方法：用来设置一个 boolean 类型的内部标志,注明目标对象发生了变化。
                 当它为true时,notifyObservers() 才会通知观察者。

    2,Observer 接口
        Observer 接口是抽象观察者,它监视目标对象的变化,当目标对象发生变化时,观察者得到通知,并调用
        update 方法,进行相应的工作。