建造者模式
    又叫生成器模式,是一种对象构建模式。它可以将复杂对象的建造遇抽象出来(抽象类别)，
    是这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象
    将一个复杂对象的构建与表示分离,使得同样的构建过程可以不同的表示
       - 复杂对象: 电脑主机
       - 构建: 电脑主机的组装过程
       - 表示: 电脑主机的表示
       - 不同的表示: 品牌换了,CPU换了,主板换了 最终出来的主机是不一样的
    特点
        * 分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。
            这个模式适用于：某个对象的构建过程复杂的情况。
        * 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，
            不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。
        * 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型
            就可以得到该对象，而无须知道其内部的具体构造细节。

     在没有使用建造者模式之前
         把产品和创建产品的过程封装在一起,耦合性增强
         客户端也需要和具体的产品类耦合
    结构
        - 抽象建造者类: 这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。
        - 具体建造者类: 实现 Builder 接口,完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。
                      核心不在于这些部件的创建,而是强调整个装配的过程
        - 产品类：要创建的复杂对象。
        - 指挥者类：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，
                  只负责保证对象各部分完整创建或按某种顺序创建。
                  它主要有两个作用,一是隔离了客户与对象的生产过程,二我负责控制产品对象的生产过程

    优缺点
        优点：
        - 建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，
          一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
        - 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
        - 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
        - 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会
          对原有功能引入风险。符合开闭原则。

         缺点：
             造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，
             因此其使用范围受到一定的限制。
    使用场景
        建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，
        所以它通常在以下场合使用。

        - 创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。
        - 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。



StringBuilder(指挥者/具体建造者/也是产品类) -> AbstractStringBuilder(具体的建造者)
                   -> Appendable (抽象的建造者) 定义了多个append抽象方法
因为设计模式是后出的,思维的总结,有时候并不是一板一眼,有时候是思想相似,会有变体



