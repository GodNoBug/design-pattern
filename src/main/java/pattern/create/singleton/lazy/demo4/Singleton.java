package pattern.create.singleton.lazy.demo4;

/**
 * 懒汉式 静态内部类式
 *   内部类是延时加载的，也就是说只会在第一次使用时加载。不使用就不加载，所以可以很好的实现单例模式。
 *   说明:
 *      静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的,
 *      只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 `static` 修饰，
 *      保证只被实例化一次，并且严格保证实例化顺序。
 *   说明：
 *      第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder
 *      并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。
 *
 *   小结：
 *      静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，
 *      并且没有任何性能影响和空间的浪费。
 */
public class Singleton {
    // 私有构造方法
    private Singleton() {
    }
    // 定义一个静态内部类
    private static class SingletonHolder{
        // 内部类中声明并初始化外部类的对象 final防止外界修改指向
        private static final Singleton INSTANCE=new Singleton();
    }

    public static Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }

}
// 常规内部类: 没有用static修饰且定义在在外部类类体中。
//      - 常规内部类中的方法可以直接使用外部类的实例变量和实例方法。在常规内部类中可以直接用内部类创建对象。
// 静态内部类
//      - 与类的其他成员相似，可以用static修饰内部类，这样的类称为静态内部类。
//      - 静态内部类与静态内部方法相似，只能访问外部类的static成员，不能直接访问外部类的实例变量，与实例方法，
//        只有通过对象引用才能访问。
//      - 由于static内部类不具有任何对外部类实例的引用，因此static内部类中不能使用this关键字来访问外部类中的实例成员，
//        但是可以访问外部类中的static成员。这与一般类的static方法相通。
//

// 局部内部类
//      - 在方法体或语句块（包括方法、构造方法、局部块或静态初始化块）内部定义的类成为局部内部类。
//        局部内部类不能加任何访问修饰符，因为它只对局部块有效。
//      - 局部内部类只在方法体中有效，就想定义的局部变量一样，在定义的方法体外不能创建局部内部类的对象
//  在方法内部定义类时，应注意以下问题：
//      1.方法定义局部内部类同方法定义局部变量一样，不能使用private、protected、public等访问修饰说明符修饰，也不能使用static修饰，但可以使用final和   abstract修饰
//      2.方法中的内部类可以访问外部类成员。对于方法的参数和局部变量，必须有final修饰才可以访问。
//      3.static方法中定义的内部类可以访问外部类定义的static成员
// 匿名内部类
//     定义类的最终目的是创建一个类的实例，但是如果某个类的实例只是用一次，则可以将类的定义与类的创建，放到与一起完成，
//     或者说在定义类的同时就创建一个类。以这种方法定义的没有名字的类成为匿名内部类。
//     它的本质是一个 带具体实现的 父类或者父接口的 匿名的 子类对象。




//
//匿名内部类：